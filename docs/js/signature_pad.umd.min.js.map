{"version":3,"file":"signature_pad.umd.min.js","sources":["../src/point.ts","../src/bezier.ts","../src/signature_event_target.ts","../src/signature_pad.ts","../src/throttle.ts"],"sourcesContent":["// Interface for point data structure used e.g. in SignaturePad#fromData method\nexport interface BasicPoint {\n  x: number;\n  y: number;\n  pressure: number;\n  time: number;\n}\n\nexport class Point implements BasicPoint {\n  public x: number;\n  public y: number;\n  public pressure: number;\n  public time: number;\n\n  constructor(x: number, y: number, pressure?: number, time?: number) {\n    if (isNaN(x) || isNaN(y)) {\n      throw new Error(`Point is invalid: (${x}, ${y})`);\n    }\n    this.x = +x;\n    this.y = +y;\n    this.pressure = pressure || 0;\n    this.time = time || Date.now();\n  }\n\n  public distanceTo(start: BasicPoint): number {\n    return Math.sqrt(\n      Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2),\n    );\n  }\n\n  public equals(other: BasicPoint): boolean {\n    return (\n      this.x === other.x &&\n      this.y === other.y &&\n      this.pressure === other.pressure &&\n      this.time === other.time\n    );\n  }\n\n  public velocityFrom(start: BasicPoint): number {\n    return this.time !== start.time\n      ? this.distanceTo(start) / (this.time - start.time)\n      : 0;\n  }\n}\n","import { BasicPoint, Point } from './point';\n\nexport class Bezier {\n  public static fromPoints(\n    points: Point[],\n    widths: { start: number; end: number },\n  ): Bezier {\n    const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n    const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n\n    return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n  }\n\n public static bezierCurve(\n      points: BasicPoint[],\n      t: number\n  ) {\n      const n = points.length - 1;\n      const newPoints = points.map(p => ({ x: p.x, y: p.y, pressure: p.pressure, time: p.time }));\n\n      for (let r = 1; r <= n; r++) {\n          for (let i = 0; i <= n - r; i++) {\n              newPoints[i].x = (1 - t) * newPoints[i].x + t * newPoints[i + 1].x;\n              newPoints[i].y = (1 - t) * newPoints[i].y + t * newPoints[i + 1].y;\n          }\n      }\n      return newPoints[0];\n  }\n\n  public static generateBezierPoints(\n      points: BasicPoint[],\n      steps: number = 100,\n  ) {\n      const curvePoints = [];\n      for (let t = 0; t <= 1; t += 1 / steps) {\n          curvePoints.push(this.bezierCurve(points, t));\n      }\n      return curvePoints;\n  }\n\n  public static generateUniformBezierPoints(\n      points: BasicPoint[],\n      numPoints: number = 500,\n  ) {\n      const densePoints = this.generateBezierPoints(points, 1000);\n\n      let totalLength = 0;\n      for (let i = 1; i < densePoints.length; i++) {\n          const dx = densePoints[i].x - densePoints[i - 1].x;\n          const dy = densePoints[i].y - densePoints[i - 1].y;\n          totalLength += Math.sqrt(dx * dx + dy * dy);\n      }\n\n      const uniformPoints = [];\n      let currentLength = 0;\n      const targetLength = totalLength / (numPoints - 1);\n      uniformPoints.push(densePoints[0]);\n\n      for (let i = 1; i < densePoints.length && uniformPoints.length < numPoints; i++) {\n          const dx = densePoints[i].x - densePoints[i - 1].x;\n          const dy = densePoints[i].y - densePoints[i - 1].y;\n          const segmentLength = Math.sqrt(dx * dx + dy * dy);\n          currentLength += segmentLength;\n\n          if (currentLength >= targetLength) {\n              uniformPoints.push(densePoints[i]);\n              currentLength = 0;\n          }\n      }\n\n      return uniformPoints;\n  }\n\n  public static generateBezierCurveBySegments(\n      points: BasicPoint[],\n      segmentSize: number = 10,\n      steps: number = 500,\n  ) {\n      const curvePoints = [];\n      for (let i = 0; i < points.length - 1; i += segmentSize - 1) {\n          const segmentPoints = points.slice(i, i + segmentSize);\n          const segmentCurve = this.generateUniformBezierPoints(segmentPoints, steps);\n          curvePoints.push(...segmentCurve);\n      }\n      return curvePoints;\n  }\n\n  private static calculateControlPoints(\n    s1: BasicPoint,\n    s2: BasicPoint,\n    s3: BasicPoint,\n  ): {\n    c1: BasicPoint;\n    c2: BasicPoint;\n  } {\n    const dx1 = s1.x - s2.x;\n    const dy1 = s1.y - s2.y;\n    const dx2 = s2.x - s3.x;\n    const dy2 = s2.y - s3.y;\n\n    const m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\n    const m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\n\n    const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n    const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n    const dxm = m1.x - m2.x;\n    const dym = m1.y - m2.y;\n\n    const k = l1 + l2 == 0 ? 0 : l2 / (l1 + l2);\n    const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\n\n    const tx = s2.x - cm.x;\n    const ty = s2.y - cm.y;\n\n    return {\n      c1: new Point(m1.x + tx, m1.y + ty),\n      c2: new Point(m2.x + tx, m2.y + ty),\n    };\n  }\n\n\n\n\n\n  constructor(\n    public startPoint: Point,\n    public control2: BasicPoint,\n    public control1: BasicPoint,\n    public endPoint: Point,\n    public startWidth: number,\n    public endWidth: number,\n  ) {}\n\n  // Returns approximated length. Code taken from https://www.lemoda.net/maths/bezier-length/index.html.\n  public length(): number {\n    const steps = 10;\n    let length = 0;\n    let px;\n    let py;\n\n    for (let i = 0; i <= steps; i += 1) {\n      const t = i / steps;\n      const cx = this.point(\n        t,\n        this.startPoint.x,\n        this.control1.x,\n        this.control2.x,\n        this.endPoint.x,\n      );\n      const cy = this.point(\n        t,\n        this.startPoint.y,\n        this.control1.y,\n        this.control2.y,\n        this.endPoint.y,\n      );\n\n      if (i > 0) {\n        const xdiff = cx - (px as number);\n        const ydiff = cy - (py as number);\n\n        length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n      }\n\n      px = cx;\n      py = cy;\n    }\n\n    return length;\n  }\n\n  // Calculate parametric value of x or y given t and the four point coordinates of a cubic bezier curve.\n  private point(\n    t: number,\n    start: number,\n    c1: number,\n    c2: number,\n    end: number,\n  ): number {\n    // prettier-ignore\n    return (       start * (1.0 - t) * (1.0 - t)  * (1.0 - t))\n         + (3.0 *  c1    * (1.0 - t) * (1.0 - t)  * t)\n         + (3.0 *  c2    * (1.0 - t) * t          * t)\n         + (       end   * t         * t          * t);\n  }\n}\n","export class SignatureEventTarget {\n  /* tslint:disable: variable-name */\n  private _et: EventTarget;\n  /* tslint:enable: variable-name */\n\n  constructor() {\n    try {\n      this._et = new EventTarget();\n    } catch {\n      // Using document as EventTarget to support iOS 13 and older.\n      // Because EventTarget constructor just exists at iOS 14 and later.\n      this._et = document;\n    }\n  }\n\n  addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject | null,\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    this._et.addEventListener(type, listener, options);\n  }\n\n  dispatchEvent(event: Event): boolean {\n    return this._et.dispatchEvent(event);\n  }\n\n  removeEventListener(\n    type: string,\n    callback: EventListenerOrEventListenerObject | null,\n    options?: boolean | EventListenerOptions,\n  ): void {\n    this._et.removeEventListener(type, callback, options);\n  }\n}\n","/**\n * The main idea and some parts of the code (e.g. drawing variable width Bézier curve) are taken from:\n * http://corner.squareup.com/2012/07/smoother-signatures.html\n *\n * Implementation of interpolation using cubic Bézier curves is taken from:\n * https://web.archive.org/web/20160323213433/http://www.benknowscode.com/2012/09/path-interpolation-using-cubic-bezier_9742.html\n *\n * Algorithm for approximated length of a Bézier curve is taken from:\n * http://www.lemoda.net/maths/bezier-length/index.html\n */\n\nimport { Bezier } from './bezier';\nimport { BasicPoint, Point } from './point';\nimport { SignatureEventTarget } from './signature_event_target';\nimport { throttle } from './throttle';\n\nexport interface SignatureEvent {\n  event: MouseEvent | TouchEvent | PointerEvent;\n  type: string;\n  x: number;\n  y: number;\n  pressure: number;\n}\n\nexport interface FromDataOptions {\n  clear?: boolean;\n}\n\nexport interface ToSVGOptions {\n  includeBackgroundColor?: boolean;\n}\n\nexport interface PointGroupOptions {\n  dotSize: number;\n  minWidth: number;\n  maxWidth: number;\n  penColor: string;\n  velocityFilterWeight: number;\n  /**\n   * This is the globalCompositeOperation for the line.\n   * *default: 'source-over'*\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n   */\n  compositeOperation: GlobalCompositeOperation;\n}\n\nexport interface Options extends Partial<PointGroupOptions> {\n  minDistance?: number;\n  backgroundColor?: string;\n  throttle?: number;\n  canvasContextOptions?: CanvasRenderingContext2DSettings;\n}\n\nexport interface PointGroup extends PointGroupOptions {\n  points: BasicPoint[];\n}\n\nexport default class SignaturePad extends SignatureEventTarget {\n  // Public stuff\n  public dotSize: number;\n  public minWidth: number;\n  public maxWidth: number;\n  public penColor: string;\n  public minDistance: number;\n  public velocityFilterWeight: number;\n  public compositeOperation: GlobalCompositeOperation;\n  public backgroundColor: string;\n  public throttle: number;\n  public canvasContextOptions: CanvasRenderingContext2DSettings;\n\n  // Private stuff\n  /* tslint:disable: variable-name */\n  private _ctx: CanvasRenderingContext2D;\n  private _drawingStroke = false;\n  private _isEmpty = true;\n  private _lastPoints: Point[] = []; // Stores up to 4 most recent points; used to generate a new curve\n  private _data: PointGroup[] = []; // Stores all points in groups (one group per line or dot)\n  private _lastVelocity = 0;\n  private _lastWidth = 0;\n  private _strokeMoveUpdate: (event: SignatureEvent) => void;\n  /* tslint:enable: variable-name */\n\n  constructor(\n    private canvas: HTMLCanvasElement,\n    options: Options = {},\n  ) {\n    super();\n    this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n    this.minWidth = options.minWidth || 0.5;\n    this.maxWidth = options.maxWidth || 2.5;\n\n    // We need to handle 0 value, so use `??` instead of `||`\n    this.throttle = options.throttle ?? 16; // in milliseconds\n    this.minDistance = options.minDistance ?? 5; // in pixels\n    this.dotSize = options.dotSize || 0;\n    this.penColor = options.penColor || 'black';\n    this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n    this.compositeOperation = options.compositeOperation || 'source-over';\n    this.canvasContextOptions = options.canvasContextOptions ?? {};\n\n    this._strokeMoveUpdate = this.throttle\n      ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle)\n      : SignaturePad.prototype._strokeUpdate;\n    this._ctx = canvas.getContext(\n      '2d',\n      this.canvasContextOptions,\n    ) as CanvasRenderingContext2D;\n\n    this.clear();\n\n    // Enable mouse and touch event handlers\n    this.on();\n  }\n\n  public clear(): void {\n    const { _ctx: ctx, canvas } = this;\n\n    // Clear canvas using background color\n    ctx.fillStyle = this.backgroundColor;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    this._data = [];\n    this._reset(this._getPointGroupOptions());\n    this._isEmpty = true;\n  }\n\n  public fromDataURL(\n    dataUrl: string,\n    options: {\n      ratio?: number;\n      width?: number;\n      height?: number;\n      xOffset?: number;\n      yOffset?: number;\n    } = {},\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const image = new Image();\n      const ratio = options.ratio || window.devicePixelRatio || 1;\n      const width = options.width || this.canvas.width / ratio;\n      const height = options.height || this.canvas.height / ratio;\n      const xOffset = options.xOffset || 0;\n      const yOffset = options.yOffset || 0;\n\n      this._reset(this._getPointGroupOptions());\n\n      image.onload = (): void => {\n        this._ctx.drawImage(image, xOffset, yOffset, width, height);\n        resolve();\n      };\n      image.onerror = (error): void => {\n        reject(error);\n      };\n      image.crossOrigin = 'anonymous';\n      image.src = dataUrl;\n\n      this._isEmpty = false;\n    });\n  }\n\n  public toDataURL(\n    type: 'image/svg+xml',\n    encoderOptions?: ToSVGOptions,\n  ): string;\n  public toDataURL(type?: string, encoderOptions?: number): string;\n  public toDataURL(\n    type = 'image/png',\n    encoderOptions?: number | ToSVGOptions | undefined,\n  ): string {\n    switch (type) {\n      case 'image/svg+xml':\n        if (typeof encoderOptions !== 'object') {\n          encoderOptions = undefined;\n        }\n        return `data:image/svg+xml;base64,${btoa(\n          this.toSVG(encoderOptions as ToSVGOptions),\n        )}`;\n      default:\n        if (typeof encoderOptions !== 'number') {\n          encoderOptions = undefined;\n        }\n        return this.canvas.toDataURL(type, encoderOptions);\n    }\n  }\n\n  public on(): void {\n    // Disable panning/zooming when touching canvas element\n    this.canvas.style.touchAction = 'none';\n    (this.canvas.style as CSSStyleDeclaration & { msTouchAction: string | null }).msTouchAction = 'none';\n    this.canvas.style.userSelect = 'none';\n\n    const isIOS =\n      /Macintosh/.test(navigator.userAgent) && 'ontouchstart' in document;\n\n    // The \"Scribble\" feature of iOS intercepts point events. So that we can\n    // lose some of them when tapping rapidly. Use touch events for iOS\n    // platforms to prevent it. See\n    // https://developer.apple.com/forums/thread/664108 for more information.\n    if (window.PointerEvent && !isIOS) {\n      this._handlePointerEvents();\n    } else {\n      this._handleMouseEvents();\n\n      if ('ontouchstart' in window) {\n        this._handleTouchEvents();\n      }\n    }\n  }\n\n  public off(): void {\n    // Enable panning/zooming when touching canvas element\n    this.canvas.style.touchAction = 'auto';\n    (this.canvas.style as CSSStyleDeclaration & { msTouchAction: string | null }).msTouchAction = 'auto';\n    this.canvas.style.userSelect = 'auto';\n\n    this.canvas.removeEventListener('pointerdown', this._handlePointerDown);\n    this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n    this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n\n    this._removeMoveUpEventListeners();\n  }\n\n  private _getListenerFunctions() {\n    const canvasWindow =\n      window.document === this.canvas.ownerDocument\n        ? window\n        : this.canvas.ownerDocument.defaultView ?? this.canvas.ownerDocument;\n\n    return {\n      addEventListener: canvasWindow.addEventListener.bind(\n        canvasWindow,\n      ) as typeof window.addEventListener,\n      removeEventListener: canvasWindow.removeEventListener.bind(\n        canvasWindow,\n      ) as typeof window.removeEventListener,\n    };\n  }\n\n  private _removeMoveUpEventListeners(): void {\n    const { removeEventListener } = this._getListenerFunctions();\n    removeEventListener('pointermove', this._handlePointerMove);\n    removeEventListener('pointerup', this._handlePointerUp);\n\n    removeEventListener('mousemove', this._handleMouseMove);\n    removeEventListener('mouseup', this._handleMouseUp);\n\n    removeEventListener('touchmove', this._handleTouchMove);\n    removeEventListener('touchend', this._handleTouchEnd);\n  }\n\n  public isEmpty(): boolean {\n    return this._isEmpty;\n  }\n\n  public fromData(\n    pointGroups: PointGroup[],\n    { clear = true }: FromDataOptions = {},\n  ): void {\n    if (clear) {\n      this.clear();\n    }\n\n    this._fromData(\n      pointGroups,\n      this._drawCurve.bind(this),\n      this._drawDot.bind(this),\n    );\n\n    this._data = this._data.concat(pointGroups);\n  }\n\n  public toData(): PointGroup[] {\n    return this._data;\n  }\n\n  public _isLeftButtonPressed(event: MouseEvent, only?: boolean): boolean {\n    if (only) {\n      return event.buttons === 1;\n    }\n\n    return (event.buttons & 1) === 1;\n  }\n  private _pointerEventToSignatureEvent(\n    event: MouseEvent | PointerEvent,\n  ): SignatureEvent {\n    return {\n      event: event,\n      type: event.type,\n      x: event.clientX,\n      y: event.clientY,\n      pressure: 'pressure' in event ? event.pressure : 0,\n    };\n  }\n\n  private _touchEventToSignatureEvent(event: TouchEvent): SignatureEvent {\n    const touch = event.changedTouches[0];\n    return {\n      event: event,\n      type: event.type,\n      x: touch.clientX,\n      y: touch.clientY,\n      pressure: touch.force,\n    };\n  }\n\n  // Event handlers\n  private _handleMouseDown = (event: MouseEvent): void => {\n    if (!this._isLeftButtonPressed(event, true) || this._drawingStroke) {\n      return;\n    }\n    this._strokeBegin(this._pointerEventToSignatureEvent(event));\n  };\n\n  private _handleMouseMove = (event: MouseEvent): void => {\n    if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {\n      // Stop when not pressing primary button or pressing multiple buttons\n      this._strokeEnd(this._pointerEventToSignatureEvent(event), false);\n      return;\n    }\n\n    this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));\n  };\n\n  private _handleMouseUp = (event: MouseEvent): void => {\n    if (this._isLeftButtonPressed(event)) {\n      return;\n    }\n\n    this._strokeEnd(this._pointerEventToSignatureEvent(event));\n  };\n\n  private _handleTouchStart = (event: TouchEvent): void => {\n    if (event.targetTouches.length !== 1 || this._drawingStroke) {\n      return;\n    }\n\n    // Prevent scrolling.\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    this._strokeBegin(this._touchEventToSignatureEvent(event));\n  };\n\n  private _handleTouchMove = (event: TouchEvent): void => {\n    if (event.targetTouches.length !== 1) {\n      return;\n    }\n\n    // Prevent scrolling.\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    if (!this._drawingStroke) {\n      this._strokeEnd(this._touchEventToSignatureEvent(event), false);\n      return;\n    }\n\n    this._strokeMoveUpdate(this._touchEventToSignatureEvent(event));\n  };\n\n  private _handleTouchEnd = (event: TouchEvent): void => {\n    if (event.targetTouches.length !== 0) {\n      return;\n    }\n\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    this.canvas.removeEventListener('touchmove', this._handleTouchMove);\n\n    this._strokeEnd(this._touchEventToSignatureEvent(event));\n  };\n\n  private _handlePointerDown = (event: PointerEvent): void => {\n    if (!event.isPrimary || !this._isLeftButtonPressed(event) || this._drawingStroke) {\n      return;\n    }\n\n    event.preventDefault();\n\n    this._strokeBegin(this._pointerEventToSignatureEvent(event));\n  };\n\n  private _handlePointerMove = (event: PointerEvent): void => {\n    if (!event.isPrimary) {\n      return;\n    }\n    if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {\n      // Stop when primary button not pressed or multiple buttons pressed\n      this._strokeEnd(this._pointerEventToSignatureEvent(event), false);\n      return;\n    }\n\n    event.preventDefault();\n    this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));\n  };\n\n  private _handlePointerUp = (event: PointerEvent): void => {\n    if (!event.isPrimary || this._isLeftButtonPressed(event)) {\n      return;\n    }\n\n    event.preventDefault();\n    this._strokeEnd(this._pointerEventToSignatureEvent(event));\n  };\n\n  private _getPointGroupOptions(group?: PointGroup): PointGroupOptions {\n    return {\n      penColor: group && 'penColor' in group ? group.penColor : this.penColor,\n      dotSize: group && 'dotSize' in group ? group.dotSize : this.dotSize,\n      minWidth: group && 'minWidth' in group ? group.minWidth : this.minWidth,\n      maxWidth: group && 'maxWidth' in group ? group.maxWidth : this.maxWidth,\n      velocityFilterWeight:\n        group && 'velocityFilterWeight' in group\n          ? group.velocityFilterWeight\n          : this.velocityFilterWeight,\n      compositeOperation:\n        group && 'compositeOperation' in group\n          ? group.compositeOperation\n          : this.compositeOperation,\n    };\n  }\n\n  // Private methods\n  private _strokeBegin(event: SignatureEvent): void {\n    const cancelled = !this.dispatchEvent(\n      new CustomEvent('beginStroke', { detail: event, cancelable: true }),\n    );\n    if (cancelled) {\n      return;\n    }\n\n    const { addEventListener } = this._getListenerFunctions();\n    switch (event.event.type) {\n      case 'mousedown':\n        addEventListener('mousemove', this._handleMouseMove);\n        addEventListener('mouseup', this._handleMouseUp);\n        break;\n      case 'touchstart':\n        addEventListener('touchmove', this._handleTouchMove);\n        addEventListener('touchend', this._handleTouchEnd);\n        break;\n      case 'pointerdown':\n        addEventListener('pointermove', this._handlePointerMove);\n        addEventListener('pointerup', this._handlePointerUp);\n        break;\n      default:\n      // do nothing\n    }\n\n    this._drawingStroke = true;\n\n    const pointGroupOptions = this._getPointGroupOptions();\n\n    const newPointGroup: PointGroup = {\n      ...pointGroupOptions,\n      points: [],\n    };\n\n    this._data.push(newPointGroup);\n    this._reset(pointGroupOptions);\n    this._strokeUpdate(event);\n  }\n\n  private _strokeUpdate(event: SignatureEvent): void {\n    if (!this._drawingStroke) {\n      return;\n    }\n\n    if (this._data.length === 0) {\n      // This can happen if clear() was called while a signature is still in progress,\n      // or if there is a race condition between start/update events.\n      this._strokeBegin(event);\n      return;\n    }\n\n    this.dispatchEvent(\n      new CustomEvent('beforeUpdateStroke', { detail: event }),\n    );\n\n    const point = this._createPoint(event.x, event.y, event.pressure);\n    const lastPointGroup = this._data[this._data.length - 1];\n    const lastPoints = lastPointGroup.points;\n    const lastPoint =\n      lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n    const isLastPointTooClose = lastPoint\n      ? point.distanceTo(lastPoint) <= this.minDistance\n      : false;\n    const pointGroupOptions = this._getPointGroupOptions(lastPointGroup);\n\n    // Skip this point if it's too close to the previous one\n    if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n      const curve = this._addPoint(point, pointGroupOptions);\n\n      if (!lastPoint) {\n        this._drawDot(point, pointGroupOptions);\n      } else if (curve) {\n        this._drawCurve(curve, pointGroupOptions);\n      }\n\n      lastPoints.push({\n        time: point.time,\n        x: point.x,\n        y: point.y,\n        pressure: point.pressure,\n      });\n    }\n\n    this.dispatchEvent(new CustomEvent('afterUpdateStroke', { detail: event }));\n  }\n\n  private _strokeEnd(event: SignatureEvent, shouldUpdate = true): void {\n    this._removeMoveUpEventListeners();\n\n    if (!this._drawingStroke) {\n      return;\n    }\n\n    if (shouldUpdate) {\n      this._strokeUpdate(event);\n    }\n\n    this._drawingStroke = false;\n    this.dispatchEvent(new CustomEvent('endStroke', { detail: event }));\n\n    \n    // if dot skip\n    if (this._data[this._data.length-1].points.length === 1) {\n      return;\n    }\n\n    // Length of the array\n    const dataLength = this._data.length;\n    \n    const curveData = this._data[dataLength-1].points;\n\n    // const uniformPoints = Bezier.generateUniformBezierPoints(curveData, 100);\n    const curvePoints = Bezier.generateBezierCurveBySegments(curveData, 10, 50);\n\n    // Replace points and redraw\n    this._data[dataLength-1].points = curvePoints;\n    const ctx = this._ctx\n\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.fromData(this._data);\n  }\n\n  private _handlePointerEvents(): void {\n    this._drawingStroke = false;\n\n    this.canvas.addEventListener('pointerdown', this._handlePointerDown);\n  }\n\n  private _handleMouseEvents(): void {\n    this._drawingStroke = false;\n\n    this.canvas.addEventListener('mousedown', this._handleMouseDown);\n  }\n\n  private _handleTouchEvents(): void {\n    this.canvas.addEventListener('touchstart', this._handleTouchStart);\n  }\n\n  // Called when a new line is started\n  private _reset(options: PointGroupOptions): void {\n    this._lastPoints = [];\n    this._lastVelocity = 0;\n    this._lastWidth = (options.minWidth + options.maxWidth) / 2;\n    this._ctx.fillStyle = options.penColor;\n    this._ctx.globalCompositeOperation = options.compositeOperation;\n  }\n\n  private _createPoint(x: number, y: number, pressure: number): Point {\n    const rect = this.canvas.getBoundingClientRect();\n\n    return new Point(\n      x - rect.left,\n      y - rect.top,\n      pressure,\n      new Date().getTime(),\n    );\n  }\n\n  // Add point to _lastPoints array and generate a new curve if there are enough points (i.e. 3)\n  private _addPoint(point: Point, options: PointGroupOptions): Bezier | null {\n    const { _lastPoints } = this;\n\n    _lastPoints.push(point);\n\n    if (_lastPoints.length > 2) {\n      // To reduce the initial lag make it work with 3 points\n      // by copying the first point to the beginning.\n      if (_lastPoints.length === 3) {\n        _lastPoints.unshift(_lastPoints[0]);\n      }\n\n      // _points array will always have 4 points here.\n      const widths = this._calculateCurveWidths(\n        _lastPoints[1],\n        _lastPoints[2],\n        options,\n      );\n      const curve = Bezier.fromPoints(_lastPoints, widths);\n\n      // Remove the first element from the list, so that there are no more than 4 points at any time.\n      _lastPoints.shift();\n\n      return curve;\n    }\n\n    return null;\n  }\n\n  private _calculateCurveWidths(\n    startPoint: Point,\n    endPoint: Point,\n    options: PointGroupOptions,\n  ): { start: number; end: number } {\n    const velocity =\n      options.velocityFilterWeight * endPoint.velocityFrom(startPoint) +\n      (1 - options.velocityFilterWeight) * this._lastVelocity;\n\n    const newWidth = this._strokeWidth(velocity, options);\n\n    const widths = {\n      end: newWidth,\n      start: this._lastWidth,\n    };\n\n    this._lastVelocity = velocity;\n    this._lastWidth = newWidth;\n\n    return widths;\n  }\n\n  private _strokeWidth(velocity: number, options: PointGroupOptions): number {\n    return Math.max(options.maxWidth / (velocity + 1), options.minWidth);\n  }\n\n  private _drawCurveSegment(x: number, y: number, width: number): void {\n    const ctx = this._ctx;\n\n    ctx.moveTo(x, y);\n    ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n    this._isEmpty = false;\n  }\n\n  private _drawCurve(curve: Bezier, options: PointGroupOptions): void {\n    const ctx = this._ctx;\n    const widthDelta = curve.endWidth - curve.startWidth;\n    // '2' is just an arbitrary number here. If only length is used, then\n    // there are gaps between curve segments :/\n    const drawSteps = Math.ceil(curve.length()) * 2;\n\n    ctx.beginPath();\n    ctx.fillStyle = options.penColor;\n\n    for (let i = 0; i < drawSteps; i += 1) {\n      // Calculate the Bezier (x, y) coordinate for this step.\n      const t = i / drawSteps;\n      const tt = t * t;\n      const ttt = tt * t;\n      const u = 1 - t;\n      const uu = u * u;\n      const uuu = uu * u;\n\n      let x = uuu * curve.startPoint.x;\n      x += 3 * uu * t * curve.control1.x;\n      x += 3 * u * tt * curve.control2.x;\n      x += ttt * curve.endPoint.x;\n\n      let y = uuu * curve.startPoint.y;\n      y += 3 * uu * t * curve.control1.y;\n      y += 3 * u * tt * curve.control2.y;\n      y += ttt * curve.endPoint.y;\n\n      const width = Math.min(\n        curve.startWidth + ttt * widthDelta,\n        options.maxWidth,\n      );\n      this._drawCurveSegment(x, y, width);\n    }\n\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  private _drawDot(point: BasicPoint, options: PointGroupOptions): void {\n    const ctx = this._ctx;\n    const width =\n      options.dotSize > 0\n        ? options.dotSize\n        : (options.minWidth + options.maxWidth) / 2;\n\n    ctx.beginPath();\n    this._drawCurveSegment(point.x, point.y, width);\n    ctx.closePath();\n    ctx.fillStyle = options.penColor;\n    ctx.fill();\n  }\n\n  private _fromData(\n    pointGroups: PointGroup[],\n    drawCurve: SignaturePad['_drawCurve'],\n    drawDot: SignaturePad['_drawDot'],\n  ): void {\n    for (const group of pointGroups) {\n      const { points } = group;\n      const pointGroupOptions = this._getPointGroupOptions(group);\n\n      if (points.length > 1) {\n        for (let j = 0; j < points.length; j += 1) {\n          const basicPoint = points[j];\n          const point = new Point(\n            basicPoint.x,\n            basicPoint.y,\n            basicPoint.pressure,\n            basicPoint.time,\n          );\n\n          if (j === 0) {\n            this._reset(pointGroupOptions);\n          }\n\n          const curve = this._addPoint(point, pointGroupOptions);\n\n          if (curve) {\n            drawCurve(curve, pointGroupOptions);\n          }\n        }\n      } else {\n        this._reset(pointGroupOptions);\n\n        drawDot(points[0], pointGroupOptions);\n      }\n    }\n  }\n\n  public toSVG({ includeBackgroundColor = false }: ToSVGOptions = {}): string {\n    const pointGroups = this._data;\n    const ratio = Math.max(window.devicePixelRatio || 1, 1);\n    const minX = 0;\n    const minY = 0;\n    const maxX = this.canvas.width / ratio;\n    const maxY = this.canvas.height / ratio;\n    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n    svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n    svg.setAttribute('viewBox', `${minX} ${minY} ${maxX} ${maxY}`);\n    svg.setAttribute('width', maxX.toString());\n    svg.setAttribute('height', maxY.toString());\n\n    if (includeBackgroundColor && this.backgroundColor) {\n      const rect = document.createElement('rect');\n      rect.setAttribute('width', '100%');\n      rect.setAttribute('height', '100%');\n      rect.setAttribute('fill', this.backgroundColor);\n\n      svg.appendChild(rect);\n    }\n\n    this._fromData(\n      pointGroups,\n\n      (curve, { penColor }) => {\n        const path = document.createElement('path');\n\n        // Need to check curve for NaN values, these pop up when drawing\n        // lines on the canvas that are not continuous. E.g. Sharp corners\n        // or stopping mid-stroke and than continuing without lifting mouse.\n        if (\n          !isNaN(curve.control1.x) &&\n          !isNaN(curve.control1.y) &&\n          !isNaN(curve.control2.x) &&\n          !isNaN(curve.control2.y)\n        ) {\n          const attr =\n            `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(\n              3,\n            )} ` +\n            `C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ` +\n            `${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ` +\n            `${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;\n          path.setAttribute('d', attr);\n          path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));\n          path.setAttribute('stroke', penColor);\n          path.setAttribute('fill', 'none');\n          path.setAttribute('stroke-linecap', 'round');\n\n          svg.appendChild(path);\n        }\n      },\n\n      (point, { penColor, dotSize, minWidth, maxWidth }) => {\n        const circle = document.createElement('circle');\n        const size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;\n        circle.setAttribute('r', size.toString());\n        circle.setAttribute('cx', point.x.toString());\n        circle.setAttribute('cy', point.y.toString());\n        circle.setAttribute('fill', penColor);\n\n        svg.appendChild(circle);\n      },\n    );\n\n    return svg.outerHTML;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-this-alias */\n// Slightly simplified version of http://stackoverflow.com/a/27078401/815507\n\nexport function throttle(\n  fn: (...args: any[]) => any,\n  wait = 250,\n): (this: any, ...args: any[]) => any {\n  let previous = 0;\n  let timeout: number | null = null;\n  let result: any;\n  let storedContext: any;\n  let storedArgs: any[];\n\n  const later = (): void => {\n    previous = Date.now();\n    timeout = null;\n    result = fn.apply(storedContext, storedArgs);\n\n    if (!timeout) {\n      storedContext = null;\n      storedArgs = [];\n    }\n  };\n\n  return function wrapper(this: any, ...args: any[]): any {\n    const now = Date.now();\n    const remaining = wait - (now - previous);\n\n    storedContext = this;\n    storedArgs = args;\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n\n      previous = now;\n      result = fn.apply(storedContext, storedArgs);\n\n      if (!timeout) {\n        storedContext = null;\n        storedArgs = [];\n      }\n    } else if (!timeout) {\n      timeout = window.setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n"],"names":["Point","constructor","x","y","pressure","time","isNaN","Error","this","Date","now","distanceTo","start","Math","sqrt","pow","equals","other","velocityFrom","Bezier","fromPoints","points","widths","c2","calculateControlPoints","c3","c1","end","bezierCurve","t","n","length","newPoints","map","p","r","i","generateBezierPoints","steps","curvePoints","push","generateUniformBezierPoints","numPoints","densePoints","totalLength","dx","dy","uniformPoints","currentLength","targetLength","generateBezierCurveBySegments","segmentSize","segmentPoints","slice","segmentCurve","s1","s2","s3","dx1","dy1","dx2","dy2","m1","m2","l1","l2","k","cm","tx","ty","startPoint","control2","control1","endPoint","startWidth","endWidth","px","py","cx","point","cy","xdiff","ydiff","SignatureEventTarget","_et","EventTarget","_a","document","addEventListener","type","listener","options","dispatchEvent","event","removeEventListener","callback","SignaturePad","canvas","super","_drawingStroke","_isEmpty","_lastPoints","_data","_lastVelocity","_lastWidth","_handleMouseDown","_isLeftButtonPressed","_strokeBegin","_pointerEventToSignatureEvent","_handleMouseMove","_strokeMoveUpdate","_strokeEnd","_handleMouseUp","_handleTouchStart","targetTouches","cancelable","preventDefault","_touchEventToSignatureEvent","_handleTouchMove","_handleTouchEnd","_handlePointerDown","isPrimary","_handlePointerMove","_handlePointerUp","velocityFilterWeight","minWidth","maxWidth","throttle","minDistance","_b","dotSize","penColor","backgroundColor","compositeOperation","canvasContextOptions","_c","fn","wait","result","storedContext","storedArgs","previous","timeout","later","apply","args","remaining","clearTimeout","window","setTimeout","prototype","_strokeUpdate","_ctx","getContext","clear","on","ctx","fillStyle","clearRect","width","height","fillRect","_reset","_getPointGroupOptions","fromDataURL","dataUrl","Promise","resolve","reject","image","Image","ratio","devicePixelRatio","xOffset","yOffset","onload","drawImage","onerror","error","crossOrigin","src","toDataURL","encoderOptions","undefined","btoa","toSVG","style","touchAction","msTouchAction","userSelect","isIOS","test","navigator","userAgent","PointerEvent","_handlePointerEvents","_handleMouseEvents","_handleTouchEvents","off","_removeMoveUpEventListeners","_getListenerFunctions","canvasWindow","ownerDocument","defaultView","bind","isEmpty","fromData","pointGroups","_fromData","_drawCurve","_drawDot","concat","toData","only","buttons","clientX","clientY","touch","changedTouches","force","group","CustomEvent","detail","pointGroupOptions","newPointGroup","_createPoint","lastPointGroup","lastPoints","lastPoint","isLastPointTooClose","curve","_addPoint","shouldUpdate","dataLength","curveData","globalCompositeOperation","rect","getBoundingClientRect","left","top","getTime","unshift","_calculateCurveWidths","shift","velocity","newWidth","_strokeWidth","max","_drawCurveSegment","moveTo","arc","PI","widthDelta","drawSteps","ceil","beginPath","tt","ttt","u","uu","uuu","min","closePath","fill","drawCurve","drawDot","j","basicPoint","includeBackgroundColor","maxX","maxY","svg","createElementNS","setAttribute","toString","createElement","appendChild","path","attr","toFixed","circle","size","outerHTML"],"mappings":"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"}